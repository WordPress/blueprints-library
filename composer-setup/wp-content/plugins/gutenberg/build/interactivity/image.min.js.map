{"version":3,"file":"./build/interactivity/image.min.js","mappings":"2CACA,IAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,ICElF,MAAM,GAFEI,EAE+B,CAAE,WAAgB,IAAMC,EAA8DC,WAAY,WAAgB,IAAMD,EAA8DE,WAAY,MAAW,IAAMF,EAA8DG,OAFrSC,EAAI,CAAC,EAAGnB,EAAoBoB,EAAED,EAAGL,GAAWK,GCKzDE,EAAqB,CAC1B,UACA,aACA,gEACA,4CACA,8CACA,4CACA,SACA,SACA,QACA,oBACA,mCDhBOP,MAAWK,ECgCnB,IAAIG,EAQAC,GAAa,EAQbC,EAAgB,EAoBpB,SAASC,EAAcC,IAIfH,GAAcI,KAAKC,MAAQJ,EAAgB,KAGjDK,OAAOC,SAAUJ,EAAIK,gBAAiBL,EAAIM,eAE5C,CAEA,MAAM,MAAEC,EAAK,QAAEC,EAAO,UAAEC,IAAcjB,EAAAA,EAAAA,OAAO,aAAc,CAC1De,MAAO,CACNG,YAAaP,OAAOQ,WACpBC,aAAcT,OAAOU,YACrB,iBAAIC,GAEH,OADYxB,EAAAA,EAAAA,cACDyB,gBAAkB,SAAW,IACzC,EACA,aAAIC,GAEH,OADY1B,EAAAA,EAAAA,cACDyB,gBAAkB,OAAS,IACvC,EACA,eAAIE,GACH,MAAMjB,GAAMV,EAAAA,EAAAA,cACZ,OAAOU,EAAIe,gBAAkBf,EAAIiB,YAAc,IAChD,EACA,qBAAIC,GAEH,IADY5B,EAAAA,EAAAA,cACH6B,YACR,MAAO,OAET,EACA,kBAAIC,GACH,MAAMpB,GAAMV,EAAAA,EAAAA,cACZ,OAAOU,EAAImB,YACRnB,EAAIqB,iBACJ,4DACJ,GAEDb,QAAS,CACRc,YAAAA,CAAcC,GACb,MAAMvB,GAAMV,EAAAA,EAAAA,cAGLU,EAAIwB,cAGXxB,EAAImB,aAAc,EAClBnB,EAAIyB,mBAAqBtB,OAAOuB,SAASC,cACzC3B,EAAI4B,YAAc,EAClB5B,EAAI6B,YAAcN,EAAMM,YAExB7B,EAAIe,iBAAkB,EACtBe,EAAW9B,EAAKA,EAAI+B,UAEpB/B,EAAIM,eACHH,OAAO6B,aAAeN,SAASO,gBAAgBC,UAIhDlC,EAAIK,gBACHF,OAAOgC,aAAeT,SAASO,gBAAgBG,WAOhDxC,EAAiBG,EAAasC,KAAM,KAAMrC,GAM1CG,OAAOmC,iBAAkB,SAAU1C,GAAgB,GACpD,EACA2C,YAAAA,GACC,MAAMvC,GAAMV,EAAAA,EAAAA,cACZU,EAAIwC,sBAAuB,EACtBxC,EAAIe,kBAOR0B,YAAY,WACXtC,OAAOuC,oBAAqB,SAAU9C,GAItCI,EAAI2C,mBAAmBC,MAAO,CAC7BC,eAAe,GAEjB,GAAG,KAEH7C,EAAIe,iBAAkB,EAExB,EACA+B,aAAAA,CAAevB,GACd,MAAMvB,GAAMV,EAAAA,EAAAA,cACPU,EAAIe,kBACW,QAAdQ,EAAM9C,KAAmC,IAAlB8C,EAAMwB,UAGhCxB,EAAMyB,UACN7C,OAAOuB,SAASC,gBACf3B,EAAIiD,uBAEL1B,EAAM2B,iBACNlD,EAAImD,qBAAqBP,SAEvBrB,EAAMyB,UACR7C,OAAOuB,SAASC,gBACf3B,EAAImD,uBAEL5B,EAAM2B,iBACNlD,EAAIiD,sBAAsBL,UAIT,WAAdrB,EAAM9C,KAAsC,KAAlB8C,EAAMwB,SACpCvC,EAAQ+B,aAAchB,GAGzB,EAGA6B,UAAAA,GACC,MAAMpD,GAAMV,EAAAA,EAAAA,eACN,IAAE+D,IAAQ9D,EAAAA,EAAAA,cAChBS,EAAIwB,aAAc,EAClBxB,EAAIsD,gBAAkBD,EAAIE,WAC1B9C,EAAU+C,iBACX,EACAC,gBAAAA,GACC5D,GAAa,CACd,EACA6D,eAAAA,CAAiBnC,IACJjC,EAAAA,EAAAA,cAOHyB,iBACRQ,EAAM2B,gBAER,EACAS,cAAAA,GAIC7D,EAAgBG,KAAKC,MACrBL,GAAa,CACd,GAEDY,UAAW,CACVmD,eAAAA,GACC,MAAM5D,GAAMV,EAAAA,EAAAA,eACN,IAAE+D,IAAQ9D,EAAAA,EAAAA,cAChBS,EAAI+B,SAAWsB,EACVA,EAAIQ,WACR7D,EAAIwB,aAAc,EAClBxB,EAAIsD,gBAAkBD,EAAIE,WAE5B,EACAO,iBAAAA,GACC,MAAM9D,GAAMV,EAAAA,EAAAA,eACN,IAAE+D,IAAQ9D,EAAAA,EAAAA,cAChBS,EAAI2C,mBAAqBU,CAC1B,EACAU,YAAAA,GACC,MAAM/D,GAAMV,EAAAA,EAAAA,eACN,IAAE+D,IAAQ9D,EAAAA,EAAAA,cAChB,GAAKS,EAAIe,gBAAkB,CAC1B,MAAMiD,EACLX,EAAIY,iBAAkBtE,GACvBK,EAAIiD,sBAAwBe,EAAmB,GAC/ChE,EAAImD,qBACHa,EAAmBA,EAAkBE,OAAS,GAG/Cb,EAAIT,OACL,CACD,EACAY,eAAAA,GACC,MAAM,IAAEH,IAAQ9D,EAAAA,EAAAA,eACV,aAAE4E,EAAY,cAAEC,EAAa,YAAEC,EAAW,aAAEC,GACjDjB,EAID,GAAsB,IAAjBc,GAAwC,IAAlBC,EAC1B,OAGD,MAAMG,EAASlB,EAAImB,cACbC,EAAcpB,EAAImB,cAAcE,YAOtC,IAAIC,EAAetB,EAAImB,cAAcI,aACrC,MAAMC,EAAUN,EAAOO,cAAe,cACtC,GAAKD,EAAU,CACd,MAAME,EAAuB5E,OAAO6E,iBAAkBH,GAEnD,CAAE,WAAY,SAAUI,SACzBF,EAAqBG,YAGtBP,EACCA,EACAE,EAAQP,aACRa,WAAYJ,EAAqBK,WACjCD,WAAYJ,EAAqBM,cAEpC,CAEA,MAAMC,EAAkBX,EAAeL,EACjCiB,EAAoBd,EAAcJ,EAElCrE,GAAMV,EAAAA,EAAAA,cAKZ,GAAuB,YAAlBU,EAAIwF,UAA0B,CAElC,MAAMC,EAAetB,EAAeC,EAIpC,GAAKqB,GAFepB,EAAcC,EAEC,CAGlC,MAAMoB,EAAkBrB,EAAcoB,EACtCzF,EAAI2F,gBACDrB,EAAeoB,GAAoB,EACrCJ,EACA,GACDtF,EAAI4F,iBAAmBL,EAAoB,EAC5C,KAAO,CAGN,MAAMM,EAAiBvB,EAAemB,EACtCzF,EAAI2F,eAAiBL,EAAkB,GACvCtF,EAAI4F,kBACDvB,EAAcwB,GAAmB,EACnCN,EACA,EACF,CACD,MACCvF,EAAI2F,eAAiBL,EAAkB,GACvCtF,EAAI4F,iBAAmBL,EAAoB,EAE7C,EACAO,iBAAAA,GACC,MAAM9F,GAAMV,EAAAA,EAAAA,eACN,IAAE+D,IAAQ9D,EAAAA,EAAAA,cAEfS,EAAIe,kBACFR,EAAMG,aAAeH,EAAMK,eAE7BkB,EAAW9B,EAAKqD,EAElB,KAmBF,SAASvB,EAAW9B,EAAKqD,GAGxB,IAAI,aACHc,EAAY,cACZC,EACAC,YAAa0B,EACbzB,aAAc0B,GACX3C,GACE5D,EAAGwG,EAAY7G,EAAG8G,GAAe7C,EAAI8C,wBAG3C,MAAMV,EAAetB,EAAeC,EAEpC,IAAIgC,EAAgBL,EAAgBC,EAIpC,GAAuB,YAAlBhG,EAAIwF,UACR,GAAKC,EAAeW,EAAgB,CACnC,MAAMC,EAAqBN,EAAgBN,EAE3CS,IAAgBF,EAAiBK,GAAuB,EACxDL,EAAiBK,CAClB,KAAO,CACN,MAAMC,EAAoBN,EAAiBP,EAE3CQ,IAAgBF,EAAgBO,GAAsB,EACtDP,EAAgBO,CACjB,CAEDF,EAAgBL,EAAgBC,EAMhC,IAAIO,EAAcpB,WACG,SAApBnF,EAAIwG,YAAyBxG,EAAIwG,YAAcrC,GAE5CsC,EAAetB,WACG,SAArBnF,EAAI0G,aAA0B1G,EAAI0G,aAAetC,GAI9CuC,EAAWJ,EAAcE,EACzBG,EAAoBL,EACpBM,EAAqBJ,EACrBK,EAAiBP,EACjBQ,EAAkBN,EAGtB,GAAKhB,EAAauB,QAAS,KAAQL,EAASK,QAAS,GAAM,CAC1D,GAAKvB,EAAekB,EAAW,CAM9B,MAAMM,EAAgBV,EAAcd,EAC/BgB,EAAeQ,EAAgBV,GACnCE,EAAeQ,EACfV,EAAcU,EAAgBxB,GAE9BgB,EAAeF,EAAcd,CAE/B,KAAO,CAMN,MAAMyB,EAAeT,EAAehB,EAC/Bc,EAAcW,EAAeT,GACjCF,EAAcW,EACdT,EAAeS,EAAezB,GAE9Bc,EAAcE,EAAehB,CAE/B,CACAqB,EAAiBP,EACjBQ,EAAkBN,EAClBE,EAAWJ,EAAcE,EAGpBL,EAAgBO,GACpBC,EAAoBL,EACpBM,EAAqBD,EAAoBR,IAEzCS,EAAqBJ,EACrBG,EAAoBC,EAAqBT,EAE3C,EAGKL,EAAgBe,GAAkBd,EAAiBe,KACvDD,EAAiBf,EACjBgB,EAAkBf,GAMnB,IAAImB,EAAoB,EACnBhH,OAAOQ,WAAa,IACxBwG,EAAoB,GACThH,OAAOQ,WAAa,OAC/BwG,EAAoB,KAErB,MAEMC,EAAiBC,KAAKC,IAC3BnH,OAAOQ,WAAawG,EACpBL,GAEKS,EAAkBF,KAAKC,IAC5BnH,OAAOU,YAPgB,GAQvBkG,GAIIX,EAFwBgB,EAAiBG,GAI7CT,EAAiBM,EACjBL,EAAkBD,EAAiBV,IAGnCW,EAAkBQ,EAClBT,EAAiBC,EAAkBX,GAGpC,MAAMoB,EAAiBzB,EAAgBe,EACjCW,EACLlB,GAAgBO,EAAiBF,GAC5Bc,EACLjB,GAAiBM,EAAkBF,GAGpC,IAAIc,EAAWjG,SAASkG,eAAgB,sBACjCD,IACNA,EAAWjG,SAASmG,cAAe,SACnCF,EAASG,GAAK,qBACdpG,SAASqG,KAAKC,YAAaL,IAQ5BA,EAASM,UAAa,6DAEoB/B,qDACCD,+CACNa,EAAiB,gDAChBC,EAAkB,2CACvBU,4CACCC,qCACPF,6CAExBrH,OAAOQ,WAAae,SAASO,gBAAgByC,2BAIjD,CAnLAvE,OAAOmC,iBACN,SA2LD,SAAmB4F,EAAMC,EAAO,IAC/B,IAAIC,EACJ,MAAO,KAKNC,aAAcD,GACdA,EAAU3F,YALI6F,KACbF,EAAU,KACVF,GAAM,GAGsBC,EAAM,CAErC,CApMCI,EAAU,KACThI,EAAMG,YAAcP,OAAOQ,WAC3BJ,EAAMK,aAAeT,OAAOU,WAAW","sources":["webpack://wp/webpack/bootstrap","webpack://wp/webpack/runtime/define property getters","webpack://wp/webpack/runtime/hasOwnProperty shorthand","webpack://wp/external module \"@wordpress/interactivity\"","webpack://wp/./packages/block-library/src/image/view.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var x = y => { var x = {}; __webpack_require__.d(x, y); return x; }\nvar y = x => () => x\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"getContext\"]: () => __WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__.getContext, [\"getElement\"]: () => __WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__.getElement, [\"store\"]: () => __WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__.store });","/**\n * WordPress dependencies\n */\nimport { store, getContext, getElement } from '@wordpress/interactivity';\n\nconst focusableSelectors = [\n\t'a[href]',\n\t'area[href]',\n\t'input:not([disabled]):not([type=\"hidden\"]):not([aria-hidden])',\n\t'select:not([disabled]):not([aria-hidden])',\n\t'textarea:not([disabled]):not([aria-hidden])',\n\t'button:not([disabled]):not([aria-hidden])',\n\t'iframe',\n\t'object',\n\t'embed',\n\t'[contenteditable]',\n\t'[tabindex]:not([tabindex^=\"-\"])',\n];\n\n/**\n * Stores a context-bound scroll handler.\n *\n * This callback could be defined inline inside of the store\n * object but it's created externally to avoid confusion about\n * how its logic is called. This logic is not referenced directly\n * by the directives in the markup because the scroll event we\n * need to listen to is triggered on the window; so by defining it\n * outside of the store, we signal that the behavior here is different.\n * If we find a compelling reason to move it to the store, feel free.\n *\n * @type {Function}\n */\nlet scrollCallback;\n\n/**\n * Tracks whether user is touching screen; used to\n * differentiate behavior for touch and mouse input.\n *\n * @type {boolean}\n */\nlet isTouching = false;\n\n/**\n * Tracks the last time the screen was touched; used to\n * differentiate behavior for touch and mouse input.\n *\n * @type {number}\n */\nlet lastTouchTime = 0;\n\n/**\n * Lightbox page-scroll handler: prevents scrolling.\n *\n * This handler is added to prevent scrolling behaviors that\n * trigger content shift while the lightbox is open.\n *\n * It would be better to accomplish this through CSS alone, but\n * using overflow: hidden is currently the only way to do so, and\n * that causes the layout to shift and prevents the zoom animation\n * from working in some cases because we're unable to account for\n * the layout shift when doing the animation calculations. Instead,\n * here we use JavaScript to prevent and reset the scrolling\n * behavior. In the future, we may be able to use CSS or overflow: hidden\n * instead to not rely on JavaScript, but this seems to be the best approach\n * for now that provides the best visual experience.\n *\n * @param {Object} ctx Context object with the `core/image` namespace.\n */\nfunction handleScroll( ctx ) {\n\t// We can't override the scroll behavior on mobile devices\n\t// because doing so breaks the pinch to zoom functionality, and we\n\t// want to allow users to zoom in further on the high-res image.\n\tif ( ! isTouching && Date.now() - lastTouchTime > 450 ) {\n\t\t// We are unable to use event.preventDefault() to prevent scrolling\n\t\t// because the scroll event can't be canceled, so we reset the position instead.\n\t\twindow.scrollTo( ctx.scrollLeftReset, ctx.scrollTopReset );\n\t}\n}\n\nconst { state, actions, callbacks } = store( 'core/image', {\n\tstate: {\n\t\twindowWidth: window.innerWidth,\n\t\twindowHeight: window.innerHeight,\n\t\tget roleAttribute() {\n\t\t\tconst ctx = getContext();\n\t\t\treturn ctx.lightboxEnabled ? 'dialog' : null;\n\t\t},\n\t\tget ariaModal() {\n\t\t\tconst ctx = getContext();\n\t\t\treturn ctx.lightboxEnabled ? 'true' : null;\n\t\t},\n\t\tget dialogLabel() {\n\t\t\tconst ctx = getContext();\n\t\t\treturn ctx.lightboxEnabled ? ctx.dialogLabel : null;\n\t\t},\n\t\tget lightboxObjectFit() {\n\t\t\tconst ctx = getContext();\n\t\t\tif ( ctx.initialized ) {\n\t\t\t\treturn 'cover';\n\t\t\t}\n\t\t},\n\t\tget enlargedImgSrc() {\n\t\t\tconst ctx = getContext();\n\t\t\treturn ctx.initialized\n\t\t\t\t? ctx.imageUploadedSrc\n\t\t\t\t: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';\n\t\t},\n\t},\n\tactions: {\n\t\tshowLightbox( event ) {\n\t\t\tconst ctx = getContext();\n\t\t\t// We can't initialize the lightbox until the reference\n\t\t\t// image is loaded, otherwise the UX is broken.\n\t\t\tif ( ! ctx.imageLoaded ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tctx.initialized = true;\n\t\t\tctx.lastFocusedElement = window.document.activeElement;\n\t\t\tctx.scrollDelta = 0;\n\t\t\tctx.pointerType = event.pointerType;\n\n\t\t\tctx.lightboxEnabled = true;\n\t\t\tsetStyles( ctx, ctx.imageRef );\n\n\t\t\tctx.scrollTopReset =\n\t\t\t\twindow.pageYOffset || document.documentElement.scrollTop;\n\n\t\t\t// In most cases, this value will be 0, but this is included\n\t\t\t// in case a user has created a page with horizontal scrolling.\n\t\t\tctx.scrollLeftReset =\n\t\t\t\twindow.pageXOffset || document.documentElement.scrollLeft;\n\n\t\t\t// We define and bind the scroll callback here so\n\t\t\t// that we can pass the context and as an argument.\n\t\t\t// We may be able to change this in the future if we\n\t\t\t// define the scroll callback in the store instead, but\n\t\t\t// this approach seems to tbe clearest for now.\n\t\t\tscrollCallback = handleScroll.bind( null, ctx );\n\n\t\t\t// We need to add a scroll event listener to the window\n\t\t\t// here because we are unable to otherwise access it via\n\t\t\t// the Interactivity API directives. If we add a native way\n\t\t\t// to access the window, we can remove this.\n\t\t\twindow.addEventListener( 'scroll', scrollCallback, false );\n\t\t},\n\t\thideLightbox() {\n\t\t\tconst ctx = getContext();\n\t\t\tctx.hideAnimationEnabled = true;\n\t\t\tif ( ctx.lightboxEnabled ) {\n\t\t\t\t// We want to wait until the close animation is completed\n\t\t\t\t// before allowing a user to scroll again. The duration of this\n\t\t\t\t// animation is defined in the styles.scss and depends on if the\n\t\t\t\t// animation is 'zoom' or 'fade', but in any case we should wait\n\t\t\t\t// a few milliseconds longer than the duration, otherwise a user\n\t\t\t\t// may scroll too soon and cause the animation to look sloppy.\n\t\t\t\tsetTimeout( function () {\n\t\t\t\t\twindow.removeEventListener( 'scroll', scrollCallback );\n\t\t\t\t\t// If we don't delay before changing the focus,\n\t\t\t\t\t// the focus ring will appear on Firefox before\n\t\t\t\t\t// the image has finished animating, which looks broken.\n\t\t\t\t\tctx.lightboxTriggerRef.focus( {\n\t\t\t\t\t\tpreventScroll: true,\n\t\t\t\t\t} );\n\t\t\t\t}, 450 );\n\n\t\t\t\tctx.lightboxEnabled = false;\n\t\t\t}\n\t\t},\n\t\thandleKeydown( event ) {\n\t\t\tconst ctx = getContext();\n\t\t\tif ( ctx.lightboxEnabled ) {\n\t\t\t\tif ( event.key === 'Tab' || event.keyCode === 9 ) {\n\t\t\t\t\t// If shift + tab it change the direction\n\t\t\t\t\tif (\n\t\t\t\t\t\tevent.shiftKey &&\n\t\t\t\t\t\twindow.document.activeElement ===\n\t\t\t\t\t\t\tctx.firstFocusableElement\n\t\t\t\t\t) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tctx.lastFocusableElement.focus();\n\t\t\t\t\t} else if (\n\t\t\t\t\t\t! event.shiftKey &&\n\t\t\t\t\t\twindow.document.activeElement ===\n\t\t\t\t\t\t\tctx.lastFocusableElement\n\t\t\t\t\t) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tctx.firstFocusableElement.focus();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( event.key === 'Escape' || event.keyCode === 27 ) {\n\t\t\t\t\tactions.hideLightbox( event );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// This is fired just by lazily loaded\n\t\t// images on the page, not all images.\n\t\thandleLoad() {\n\t\t\tconst ctx = getContext();\n\t\t\tconst { ref } = getElement();\n\t\t\tctx.imageLoaded = true;\n\t\t\tctx.imageCurrentSrc = ref.currentSrc;\n\t\t\tcallbacks.setButtonStyles();\n\t\t},\n\t\thandleTouchStart() {\n\t\t\tisTouching = true;\n\t\t},\n\t\thandleTouchMove( event ) {\n\t\t\tconst ctx = getContext();\n\t\t\t// On mobile devices, we want to prevent triggering the\n\t\t\t// scroll event because otherwise the page jumps around as\n\t\t\t// we reset the scroll position. This also means that closing\n\t\t\t// the lightbox requires that a user perform a simple tap. This\n\t\t\t// may be changed in the future if we find a better alternative\n\t\t\t// to override or reset the scroll position during swipe actions.\n\t\t\tif ( ctx.lightboxEnabled ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t},\n\t\thandleTouchEnd() {\n\t\t\t// We need to wait a few milliseconds before resetting\n\t\t\t// to ensure that pinch to zoom works consistently\n\t\t\t// on mobile devices when the lightbox is open.\n\t\t\tlastTouchTime = Date.now();\n\t\t\tisTouching = false;\n\t\t},\n\t},\n\tcallbacks: {\n\t\tinitOriginImage() {\n\t\t\tconst ctx = getContext();\n\t\t\tconst { ref } = getElement();\n\t\t\tctx.imageRef = ref;\n\t\t\tif ( ref.complete ) {\n\t\t\t\tctx.imageLoaded = true;\n\t\t\t\tctx.imageCurrentSrc = ref.currentSrc;\n\t\t\t}\n\t\t},\n\t\tinitTriggerButton() {\n\t\t\tconst ctx = getContext();\n\t\t\tconst { ref } = getElement();\n\t\t\tctx.lightboxTriggerRef = ref;\n\t\t},\n\t\tinitLightbox() {\n\t\t\tconst ctx = getContext();\n\t\t\tconst { ref } = getElement();\n\t\t\tif ( ctx.lightboxEnabled ) {\n\t\t\t\tconst focusableElements =\n\t\t\t\t\tref.querySelectorAll( focusableSelectors );\n\t\t\t\tctx.firstFocusableElement = focusableElements[ 0 ];\n\t\t\t\tctx.lastFocusableElement =\n\t\t\t\t\tfocusableElements[ focusableElements.length - 1 ];\n\n\t\t\t\t// Move focus to the dialog when opening it.\n\t\t\t\tref.focus();\n\t\t\t}\n\t\t},\n\t\tsetButtonStyles() {\n\t\t\tconst { ref } = getElement();\n\t\t\tconst { naturalWidth, naturalHeight, offsetWidth, offsetHeight } =\n\t\t\t\tref;\n\n\t\t\t// If the image isn't loaded yet, we can't\n\t\t\t// calculate where the button should be.\n\t\t\tif ( naturalWidth === 0 || naturalHeight === 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst figure = ref.parentElement;\n\t\t\tconst figureWidth = ref.parentElement.clientWidth;\n\n\t\t\t// We need special handling for the height because\n\t\t\t// a caption will cause the figure to be taller than\n\t\t\t// the image, which means we need to account for that\n\t\t\t// when calculating the placement of the button in the\n\t\t\t// top right corner of the image.\n\t\t\tlet figureHeight = ref.parentElement.clientHeight;\n\t\t\tconst caption = figure.querySelector( 'figcaption' );\n\t\t\tif ( caption ) {\n\t\t\t\tconst captionComputedStyle = window.getComputedStyle( caption );\n\t\t\t\tif (\n\t\t\t\t\t! [ 'absolute', 'fixed' ].includes(\n\t\t\t\t\t\tcaptionComputedStyle.position\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tfigureHeight =\n\t\t\t\t\t\tfigureHeight -\n\t\t\t\t\t\tcaption.offsetHeight -\n\t\t\t\t\t\tparseFloat( captionComputedStyle.marginTop ) -\n\t\t\t\t\t\tparseFloat( captionComputedStyle.marginBottom );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst buttonOffsetTop = figureHeight - offsetHeight;\n\t\t\tconst buttonOffsetRight = figureWidth - offsetWidth;\n\n\t\t\tconst ctx = getContext();\n\n\t\t\t// In the case of an image with object-fit: contain, the\n\t\t\t// size of the <img> element can be larger than the image itself,\n\t\t\t// so we need to calculate where to place the button.\n\t\t\tif ( ctx.scaleAttr === 'contain' ) {\n\t\t\t\t// Natural ratio of the image.\n\t\t\t\tconst naturalRatio = naturalWidth / naturalHeight;\n\t\t\t\t// Offset ratio of the image.\n\t\t\t\tconst offsetRatio = offsetWidth / offsetHeight;\n\n\t\t\t\tif ( naturalRatio >= offsetRatio ) {\n\t\t\t\t\t// If it reaches the width first, keep\n\t\t\t\t\t// the width and compute the height.\n\t\t\t\t\tconst referenceHeight = offsetWidth / naturalRatio;\n\t\t\t\t\tctx.imageButtonTop =\n\t\t\t\t\t\t( offsetHeight - referenceHeight ) / 2 +\n\t\t\t\t\t\tbuttonOffsetTop +\n\t\t\t\t\t\t16;\n\t\t\t\t\tctx.imageButtonRight = buttonOffsetRight + 16;\n\t\t\t\t} else {\n\t\t\t\t\t// If it reaches the height first, keep\n\t\t\t\t\t// the height and compute the width.\n\t\t\t\t\tconst referenceWidth = offsetHeight * naturalRatio;\n\t\t\t\t\tctx.imageButtonTop = buttonOffsetTop + 16;\n\t\t\t\t\tctx.imageButtonRight =\n\t\t\t\t\t\t( offsetWidth - referenceWidth ) / 2 +\n\t\t\t\t\t\tbuttonOffsetRight +\n\t\t\t\t\t\t16;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tctx.imageButtonTop = buttonOffsetTop + 16;\n\t\t\t\tctx.imageButtonRight = buttonOffsetRight + 16;\n\t\t\t}\n\t\t},\n\t\tsetStylesOnResize() {\n\t\t\tconst ctx = getContext();\n\t\t\tconst { ref } = getElement();\n\t\t\tif (\n\t\t\t\tctx.lightboxEnabled &&\n\t\t\t\t( state.windowWidth || state.windowHeight )\n\t\t\t) {\n\t\t\t\tsetStyles( ctx, ref );\n\t\t\t}\n\t\t},\n\t},\n} );\n\nwindow.addEventListener(\n\t'resize',\n\tdebounce( () => {\n\t\tstate.windowWidth = window.innerWidth;\n\t\tstate.windowHeight = window.innerHeight;\n\t} )\n);\n\n/**\n * Computes styles for the lightbox and adds them to the document.\n *\n * @function\n * @param {Object} ctx - Context for the `core/image` namespace.\n * @param {Object} ref - The element reference.\n */\nfunction setStyles( ctx, ref ) {\n\t// The reference img element lies adjacent\n\t// to the event target button in the DOM.\n\tlet {\n\t\tnaturalWidth,\n\t\tnaturalHeight,\n\t\toffsetWidth: originalWidth,\n\t\toffsetHeight: originalHeight,\n\t} = ref;\n\tlet { x: screenPosX, y: screenPosY } = ref.getBoundingClientRect();\n\n\t// Natural ratio of the image clicked to open the lightbox.\n\tconst naturalRatio = naturalWidth / naturalHeight;\n\t// Original ratio of the image clicked to open the lightbox.\n\tlet originalRatio = originalWidth / originalHeight;\n\n\t// If it has object-fit: contain, recalculate the original sizes\n\t// and the screen position without the blank spaces.\n\tif ( ctx.scaleAttr === 'contain' ) {\n\t\tif ( naturalRatio > originalRatio ) {\n\t\t\tconst heightWithoutSpace = originalWidth / naturalRatio;\n\t\t\t// Recalculate screen position without the top space.\n\t\t\tscreenPosY += ( originalHeight - heightWithoutSpace ) / 2;\n\t\t\toriginalHeight = heightWithoutSpace;\n\t\t} else {\n\t\t\tconst widthWithoutSpace = originalHeight * naturalRatio;\n\t\t\t// Recalculate screen position without the left space.\n\t\t\tscreenPosX += ( originalWidth - widthWithoutSpace ) / 2;\n\t\t\toriginalWidth = widthWithoutSpace;\n\t\t}\n\t}\n\toriginalRatio = originalWidth / originalHeight;\n\n\t// Typically, we use the image's full-sized dimensions. If those\n\t// dimensions have not been set (i.e. an external image with only one size),\n\t// the image's dimensions in the lightbox are the same\n\t// as those of the image in the content.\n\tlet imgMaxWidth = parseFloat(\n\t\tctx.targetWidth !== 'none' ? ctx.targetWidth : naturalWidth\n\t);\n\tlet imgMaxHeight = parseFloat(\n\t\tctx.targetHeight !== 'none' ? ctx.targetHeight : naturalHeight\n\t);\n\n\t// Ratio of the biggest image stored in the database.\n\tlet imgRatio = imgMaxWidth / imgMaxHeight;\n\tlet containerMaxWidth = imgMaxWidth;\n\tlet containerMaxHeight = imgMaxHeight;\n\tlet containerWidth = imgMaxWidth;\n\tlet containerHeight = imgMaxHeight;\n\t// Check if the target image has a different ratio than the original one (thumbnail).\n\t// Recalculate the width and height.\n\tif ( naturalRatio.toFixed( 2 ) !== imgRatio.toFixed( 2 ) ) {\n\t\tif ( naturalRatio > imgRatio ) {\n\t\t\t// If the width is reached before the height, we keep the maxWidth\n\t\t\t// and recalculate the height.\n\t\t\t// Unless the difference between the maxHeight and the reducedHeight\n\t\t\t// is higher than the maxWidth, where we keep the reducedHeight and\n\t\t\t// recalculate the width.\n\t\t\tconst reducedHeight = imgMaxWidth / naturalRatio;\n\t\t\tif ( imgMaxHeight - reducedHeight > imgMaxWidth ) {\n\t\t\t\timgMaxHeight = reducedHeight;\n\t\t\t\timgMaxWidth = reducedHeight * naturalRatio;\n\t\t\t} else {\n\t\t\t\timgMaxHeight = imgMaxWidth / naturalRatio;\n\t\t\t}\n\t\t} else {\n\t\t\t// If the height is reached before the width, we keep the maxHeight\n\t\t\t// and recalculate the width.\n\t\t\t// Unless the difference between the maxWidth and the reducedWidth\n\t\t\t// is higher than the maxHeight, where we keep the reducedWidth and\n\t\t\t// recalculate the height.\n\t\t\tconst reducedWidth = imgMaxHeight * naturalRatio;\n\t\t\tif ( imgMaxWidth - reducedWidth > imgMaxHeight ) {\n\t\t\t\timgMaxWidth = reducedWidth;\n\t\t\t\timgMaxHeight = reducedWidth / naturalRatio;\n\t\t\t} else {\n\t\t\t\timgMaxWidth = imgMaxHeight * naturalRatio;\n\t\t\t}\n\t\t}\n\t\tcontainerWidth = imgMaxWidth;\n\t\tcontainerHeight = imgMaxHeight;\n\t\timgRatio = imgMaxWidth / imgMaxHeight;\n\n\t\t// Calculate the max size of the container.\n\t\tif ( originalRatio > imgRatio ) {\n\t\t\tcontainerMaxWidth = imgMaxWidth;\n\t\t\tcontainerMaxHeight = containerMaxWidth / originalRatio;\n\t\t} else {\n\t\t\tcontainerMaxHeight = imgMaxHeight;\n\t\t\tcontainerMaxWidth = containerMaxHeight * originalRatio;\n\t\t}\n\t}\n\n\t// If the image has been pixelated on purpose, keep that size.\n\tif ( originalWidth > containerWidth || originalHeight > containerHeight ) {\n\t\tcontainerWidth = originalWidth;\n\t\tcontainerHeight = originalHeight;\n\t}\n\n\t// Calculate the final lightbox image size and the\n\t// scale factor. MaxWidth is either the window container\n\t// (accounting for padding) or the image resolution.\n\tlet horizontalPadding = 0;\n\tif ( window.innerWidth > 480 ) {\n\t\thorizontalPadding = 80;\n\t} else if ( window.innerWidth > 1920 ) {\n\t\thorizontalPadding = 160;\n\t}\n\tconst verticalPadding = 80;\n\n\tconst targetMaxWidth = Math.min(\n\t\twindow.innerWidth - horizontalPadding,\n\t\tcontainerWidth\n\t);\n\tconst targetMaxHeight = Math.min(\n\t\twindow.innerHeight - verticalPadding,\n\t\tcontainerHeight\n\t);\n\tconst targetContainerRatio = targetMaxWidth / targetMaxHeight;\n\n\tif ( originalRatio > targetContainerRatio ) {\n\t\t// If targetMaxWidth is reached before targetMaxHeight\n\t\tcontainerWidth = targetMaxWidth;\n\t\tcontainerHeight = containerWidth / originalRatio;\n\t} else {\n\t\t// If targetMaxHeight is reached before targetMaxWidth\n\t\tcontainerHeight = targetMaxHeight;\n\t\tcontainerWidth = containerHeight * originalRatio;\n\t}\n\n\tconst containerScale = originalWidth / containerWidth;\n\tconst lightboxImgWidth =\n\t\timgMaxWidth * ( containerWidth / containerMaxWidth );\n\tconst lightboxImgHeight =\n\t\timgMaxHeight * ( containerHeight / containerMaxHeight );\n\n\t// Add the CSS variables needed.\n\tlet styleTag = document.getElementById( 'wp-lightbox-styles' );\n\tif ( ! styleTag ) {\n\t\tstyleTag = document.createElement( 'style' );\n\t\tstyleTag.id = 'wp-lightbox-styles';\n\t\tdocument.head.appendChild( styleTag );\n\t}\n\n\t// As of this writing, using the calculations above will render the lightbox\n\t// with a small, erroneous whitespace on the left side of the image in iOS Safari,\n\t// perhaps due to an inconsistency in how browsers handle absolute positioning and CSS\n\t// transformation. In any case, adding 1 pixel to the container width and height solves\n\t// the problem, though this can be removed if the issue is fixed in the future.\n\tstyleTag.innerHTML = `\n\t\t:root {\n\t\t\t--wp--lightbox-initial-top-position: ${ screenPosY }px;\n\t\t\t--wp--lightbox-initial-left-position: ${ screenPosX }px;\n\t\t\t--wp--lightbox-container-width: ${ containerWidth + 1 }px;\n\t\t\t--wp--lightbox-container-height: ${ containerHeight + 1 }px;\n\t\t\t--wp--lightbox-image-width: ${ lightboxImgWidth }px;\n\t\t\t--wp--lightbox-image-height: ${ lightboxImgHeight }px;\n\t\t\t--wp--lightbox-scale: ${ containerScale };\n\t\t\t--wp--lightbox-scrollbar-width: ${\n\t\t\t\twindow.innerWidth - document.documentElement.clientWidth\n\t\t\t}px;\n\t\t}\n\t`;\n}\n\n/**\n * Debounces a function call.\n *\n * @function\n * @param {Function} func - A function to be called\n * @param {number}   wait - The time to wait before calling the function\n */\nfunction debounce( func, wait = 50 ) {\n\tlet timeout;\n\treturn () => {\n\t\tconst later = () => {\n\t\t\ttimeout = null;\n\t\t\tfunc();\n\t\t};\n\t\tclearTimeout( timeout );\n\t\ttimeout = setTimeout( later, wait );\n\t};\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","y","__WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__","getContext","getElement","store","x","d","focusableSelectors","scrollCallback","isTouching","lastTouchTime","handleScroll","ctx","Date","now","window","scrollTo","scrollLeftReset","scrollTopReset","state","actions","callbacks","windowWidth","innerWidth","windowHeight","innerHeight","roleAttribute","lightboxEnabled","ariaModal","dialogLabel","lightboxObjectFit","initialized","enlargedImgSrc","imageUploadedSrc","showLightbox","event","imageLoaded","lastFocusedElement","document","activeElement","scrollDelta","pointerType","setStyles","imageRef","pageYOffset","documentElement","scrollTop","pageXOffset","scrollLeft","bind","addEventListener","hideLightbox","hideAnimationEnabled","setTimeout","removeEventListener","lightboxTriggerRef","focus","preventScroll","handleKeydown","keyCode","shiftKey","firstFocusableElement","preventDefault","lastFocusableElement","handleLoad","ref","imageCurrentSrc","currentSrc","setButtonStyles","handleTouchStart","handleTouchMove","handleTouchEnd","initOriginImage","complete","initTriggerButton","initLightbox","focusableElements","querySelectorAll","length","naturalWidth","naturalHeight","offsetWidth","offsetHeight","figure","parentElement","figureWidth","clientWidth","figureHeight","clientHeight","caption","querySelector","captionComputedStyle","getComputedStyle","includes","position","parseFloat","marginTop","marginBottom","buttonOffsetTop","buttonOffsetRight","scaleAttr","naturalRatio","referenceHeight","imageButtonTop","imageButtonRight","referenceWidth","setStylesOnResize","originalWidth","originalHeight","screenPosX","screenPosY","getBoundingClientRect","originalRatio","heightWithoutSpace","widthWithoutSpace","imgMaxWidth","targetWidth","imgMaxHeight","targetHeight","imgRatio","containerMaxWidth","containerMaxHeight","containerWidth","containerHeight","toFixed","reducedHeight","reducedWidth","horizontalPadding","targetMaxWidth","Math","min","targetMaxHeight","containerScale","lightboxImgWidth","lightboxImgHeight","styleTag","getElementById","createElement","id","head","appendChild","innerHTML","func","wait","timeout","clearTimeout","later","debounce"],"sourceRoot":""}