<?php

use Swaggest\JsonSchema\Schema;
use Swaggest\PhpCodeBuilder\App\PhpApp;
use Swaggest\PhpCodeBuilder\JsonSchema\ClassHookCallback;
use Swaggest\PhpCodeBuilder\JsonSchema\PhpBuilder;
use Swaggest\PhpCodeBuilder\PhpClass;
use Swaggest\PhpCodeBuilder\PhpClassTraitInterface;
use Swaggest\PhpCodeBuilder\PhpCode;
use Swaggest\PhpCodeBuilder\PhpConstant;
use Swaggest\PhpCodeBuilder\PhpFunction;
use Swaggest\PhpCodeBuilder\PhpInterface;
use Swaggest\PhpCodeBuilder\PhpNamedVar;
use Swaggest\PhpCodeBuilder\PhpTrait;

require __DIR__ . '/../../../../vendor/autoload.php';

$blueprintSchema = json_decode( file_get_contents( __DIR__ . '/../schema.json' ) );

$schema = Schema::import( $blueprintSchema );

$targetPath = __DIR__ . '/../';
if ( ! file_exists( $targetPath ) ) {
	mkdir( $targetPath, 0777, true );
}
$validatedNs = 'WordPress\\Blueprints\\Model\\InternalValidated';
$dirtyNs = 'WordPress\\Blueprints\\Model\\Dirty';
$runnerNs = 'WordPress\\Blueprints\\Runner\\Step';

/**
 * Same as \Swaggest\PhpCodeBuilder\App\PhpApp. but does not
 * remove everything from the $targetPath directory. We store
 * more than just the autogenerated files in there and we don't
 * want to remove them. This version of the class only clears
 * the directories associated with the namespaces we use for
 * the generated classes.
 */
class CarefulPhpApp extends PhpApp {
	protected $psr4Namespaces = [];
	protected $directoriesToClear = [];
	protected $defaultFileComment = "AUTOGENERATED FILE â€“ DO NOT CHANGE MANUALLY\nAll your changes will get overridden. See the README for more details.";


	public function setNamespaceRoot( $namespace, $relativePath = './src/', $clear = false ) {
		$relativePath = rtrim( $relativePath, '/' ) . '/';
		$this->psr4Namespaces[ $namespace ] = $relativePath;
		parent::setNamespaceRoot( $namespace, $relativePath );

		if ( $clear ) {
			$this->directoriesToClear[] = $relativePath;
		}

		return $this;
	}

	public function generatedClassExists( $rootPath, $namespace, $className ) {
		$namespacePath = $this->psr4Namespaces[ $namespace ];
		$rootPath = rtrim( $rootPath, '/' ) . '/';
		$classPath = $rootPath . $namespacePath . $className . '.php';

		return file_exists( $classPath );
	}

	public function addClass( PhpClassTraitInterface $class ) {
		$filesBefore = $this->getFiles();
		parent::addClass( $class );
		$filesAfter = $this->getFiles();
		$diff = array_diff_key( $filesAfter, $filesBefore );

		$file = array_values( $diff )[0];
		$this->setAutogeneratedFileComment( $file, $this->defaultFileComment );

		return $file;
	}

	public function setAutogeneratedFileComment( $file, $comment ) {
		$phpFileRef = new ReflectionClass( Swaggest\PhpCodeBuilder\PhpFile::class );
		$fileCommentProp = $phpFileRef->getProperty( "comment" );
		$fileCommentProp->setValue(
			$file,
			$comment
		);
	}

	public function getFiles() {
		$appRef = new ReflectionClass( parent::class );
		$appFilesProp = $appRef->getProperty( 'files' );

		return $appFilesProp->getValue( $this );
	}


	public function store( $path ) {
		foreach ( $this->directoriesToClear as $relativePath ) {
			$dir = realpath( $path . $relativePath );
			foreach ( glob( $dir . '/*.php' ) as $oldFile ) {
				unlink( $oldFile );
			}
		}

		if ( DIRECTORY_SEPARATOR === '\\' ) {
			$path = str_replace( '\\', '/', $path );
		}

		$path = rtrim( $path, '/' ) . '/';

		foreach ( $this->files as $filepath => $contents ) {
			$this->putContents( $path . $filepath, $contents );
		}
	}

}

$app = new CarefulPhpApp();
$app->setNamespaceRoot( $validatedNs, './Model/InternalValidated', $clear = true );
$app->setNamespaceRoot( $dirtyNs, './Model/Dirty', $clear = true );
$app->setNamespaceRoot( $runnerNs, './Runner/Step' );

$builder = new PhpBuilder();
$builder->buildSetters = true;
$builder->makeEnumConstants = true;
$builder->declarePropertyDefaults = true;

$builder->classCreatedHook = new ClassHookCallback(
	function ( PhpClass $class, $path, $schema ) use ( $app, $dirtyNs ) {
		$desc = '';
		if ( $schema->title ) {
			$desc = $schema->title;
		}
		if ( $schema->description ) {
			$desc .= "\n" . $schema->description;
		}
		if ( $fromRefs = $schema->getFromRefs() ) {
			$desc .= "\nBuilt from " . implode( "\n" . ' <- ', $fromRefs );
		}

		$class->setDescription( trim( $desc ) );
		$class->setNamespace( $dirtyNs );
		if ( '#' === $path ) {
			$class->setName( 'Blueprint' ); // Class name for root schema
		} elseif ( strpos( $path, '#/definitions/' ) === 0 ) {
			$class->setName(
				PhpCode::makePhpClassName( substr( $path,
					strlen( '#/definitions/' ) ) )
			);
		}
		$app->addClass( $class );
	}
);

// Make all FileReference and StepDefinition models share a
// common interface.
// I didn't find any way of getting those information from $schema,
// so here's a native extraction of all the relevant classes.
$interfaces = [
	'FileReference'  => [
		'interfaceName' => 'FileReferenceInterface',
	],
	'StepDefinition' => [
		'interfaceName' => 'StepInterface',
	],
];
foreach ( $interfaces as $definitionName => $details ) {
	$schemaDefinition = $blueprintSchema->definitions->{$definitionName};
	$interfaces[ $definitionName ]['implementers'] = [];
	$relatedRefs = property_exists( $schemaDefinition,
		'anyOf' ) ? $schemaDefinition->anyOf : $schemaDefinition->oneOf;
	foreach ( $relatedRefs as $name => $property ) {
		if ( $property->{'$ref'} ) {
			$parts = explode( '/', $property->{'$ref'} );
			$interfaces[ $definitionName ]['implementers'][] = end( $parts );
		}
	}
	$interfaces[ $definitionName ]['interface'] = ( new PhpInterface() )
		->setName( $details['interfaceName'] )
		->setNamespace( $validatedNs );
	$app->addClass( $interfaces[ $definitionName ]['interface'] );
}

$builder->classPreparedHook = new ClassHookCallback(
	function ( PhpClass $class, $path, $schema ) use (
		$app,
		$targetPath,
		$dirtyNs,
		$validatedNs,
		$runnerNs,
		$interfaces,
	) {
		$validatedClass = new PhpClass();
		// Remove the "Builder" suffix from the class name
		$validatedClassName = 'Valid' . $class->getName();
		$validatedFullName = '\\' . $validatedNs . '\\' . $validatedClassName;
		$validatedClass->setName( $validatedClassName );
		$validatedClass->setNamespace( $validatedNs );

		// Add the relevant interfaces, like StepDefinitionInterface
		foreach ( $interfaces as $details ) {
			if ( in_array( $validatedClassName, $details['implementers'] ) ) {
				$validatedClass->addImplements( $details['interface'] );
			}
		}

		// Add all the properties from the builder class to the data class
		foreach ( $class->getProperties() as $property ) {
			$validatedClass->addProperty( $property );
		}

		$class->addMethod( ( new PhpFunction( 'create' ) )->setIsStatic( true )->setBody( <<<'METHOD'
return new static();
METHOD
		) );

		// Add default values for the "const" properties
		$schemaProperties = $schema->getProperties();

		foreach ( $validatedClass->getProperties() as $property ) {
			$name = $property->getNamedVar()->getName();
			if ( $schemaProperties->$name && $schemaProperties->$name->const ) {
				if (
					( str_ends_with( $validatedClassName, 'Step' ) && $name === 'step' )
					|| ( str_ends_with( $validatedClassName, 'Resource' ) && $name === 'resource' )
				) {
					$const = new PhpConstant( 'SLUG', $schemaProperties->$name->const );
					$validatedClass->addConstant( $const );
					$class->addConstant( $const );
				}
				$property->getNamedVar()->setDefault( $schemaProperties->$name->const );
			}
		}

		// Let's add a constructor to the Validated class.
		$propsForConstructor = $validatedClass->getProperties();
		foreach ( $propsForConstructor as $k => $property ) {
			$name = $property->getNamedVar()->getName();
			// Remove the "const" properties from the constructor, they
			// are set as default values and shouldn't be changed.
			if ( $schemaProperties->$name && $schemaProperties->$name->const ) {
				unset( $propsForConstructor[ $k ] );
			}
		}
		$propsForConstructor = array_values( $propsForConstructor );

		usort( $propsForConstructor, function ( $a, $b ) {
			// Move the "continueOnError" and "progress" to the end of the argument list
			foreach ( [ 'continueOnError', 'progress' ] as $prop ) {
				if ( $a->getNamedVar()->getName() === $prop || $b->getNamedVar()->getName() === $prop ) {
					return $a->getNamedVar()->getName() === $prop ? 1 : - 1;
				}
			}

			// Move the properties with default values before the two above
			if ( $a->getNamedVar()->renderDefault() ) {
				return - 1;
			}
			if ( $b->getNamedVar()->renderDefault() ) {
				return - 1;
			}

			return 0;
		} );


		// Add a normalize method to the builder class that will return a new instance of the data class
		$validatedClassConstructor = new PhpFunction( '__construct' );
		$constructorBody = '';
		$normalizeBody = "return new $validatedFullName(\n";
		foreach ( $propsForConstructor as $k => $property ) {
			$namedVar = clone $property->getNamedVar();
			$argumentType = $namedVar->getType()->renderArgumentType() ?? '';
			$className = substr( $argumentType, strrpos( $argumentType, '\\' ) + 1 );
			$name = $property->getNamedVar()->getName();
			if ( $className === 'Progress' ) {
				$namedVar->setDefault( null );
			}
			if ( ! $schema->required || ! in_array( $name, $schema->required, true ) ) {
				$namedVar->setDefault( null );
			}
			$validatedClassConstructor->addArgument( $namedVar );
			$isLast = $k === count( $propsForConstructor ) - 1;
			$comma = $isLast ? '' : ',';
			$normalizeBody .= "\$this->{$name}$comma\n";
			$constructorBody .= "\$this->$name = \$$name;\n";
		}
		$normalizeBody .= ');';
		$validatedClassConstructor->setBody( $constructorBody );
		$validatedClass->addMethod( $validatedClassConstructor );

		$class->addMethod( ( new PhpFunction( 'normalize' ) )->setBody( $normalizeBody ) );
		$class->addMethod( ( new PhpFunction( 'recursiveJsonSerialize' ) )->addArgument(
			new PhpNamedVar( 'objectMaybe' )
		)->setVisibility( 'private' )->setBody( <<<'METHOD'
if ( is_array( $objectMaybe ) ) {
	return array_map([$this, 'recursiveJsonSerialize'], $objectMaybe);
} elseif ( $objectMaybe instanceof \Swaggest\JsonSchema\Structure\ClassStructureContract ) {
	return $objectMaybe->normalize();
} else {
	return $objectMaybe;
}
METHOD
		) );

		$app->addClass( $validatedClass );

		// We want to extend the data class so let's replace the default inheritance
		// approach in the schema class with a trait and an interface
		$class->addTrait( new PhpTrait( '\\Swaggest\\JsonSchema\\Structure\\ClassStructureTrait' ) );
		$class->addImplements( ( new PhpInterface() )->setName( '\\Swaggest\\JsonSchema\\Structure\\ClassStructureContract' ) );

		$runnerClassName = $validatedClassName . 'Runner';
		// Create a Step Handler class if it's needed but missing
		if (
			str_ends_with( $validatedClassName, 'Step' ) &&
			! $app->generatedClassExists( $targetPath, $runnerNs, $runnerClassName )
		) {
			$baseStepRunnerClass = new PhpClass();
			$baseStepRunnerClass->setNamespace( $runnerNs );
			$baseStepRunnerClass->setName( 'BaseStepRunner' );

			$runnerClass = new PhpClass();
			$runnerClass->setNamespace( $runnerNs );
			$runnerClass->setExtends( $baseStepRunnerClass );
			$runnerClass->setName( $runnerClassName );
			$execute = new PhpFunction( 'run' );
			$execute->setBody( '' );

			$input = new PhpNamedVar( 'input' );
			$input->setType( $validatedClass );
			$execute->addArgument( $input );

			$tracker = new PhpNamedVar( 'tracker' );
			$tracker->setType( ( new PhpClass() )->setFullyQualifiedName( 'WordPress\\Blueprints\\Progress\\Tracker' ) );
			$execute->addArgument( $tracker );

			$runnerClass->addMethod( $execute );
			$file = $app->addClass( $runnerClass );
			$app->setAutogeneratedFileComment( $file, '' );
		}
	}
);

$builder->getType( $schema );
$app->store( $targetPath );
